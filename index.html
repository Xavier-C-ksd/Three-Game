<!doctype html>
<html>
  <head>
    <title>FPS Maze - 1.2.0</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
      }
      canvas {
        display: block;
      }
    </style>
  </head>
  <body>
    <script type="module">
      import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160.1/build/three.module.js"

      let scene = new THREE.Scene()

      let yawObject = new THREE.Object3D()
      yawObject.position.set(0, 1.6, 5)
      scene.add(yawObject)

      let camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        1000,
      )
      yawObject.add(camera)

      let renderer = new THREE.WebGLRenderer()
      renderer.setSize(window.innerWidth, window.innerHeight)
      renderer.shadowMap.enabled = true
      renderer.shadowMap.type = THREE.PCFSoftShadowMap
      document.body.appendChild(renderer.domElement)

      const gravity = -0.01
      const jumpForce = 0.25
      const baseSpeed = 0.03
      const sprintSpeed = 0.05
      const turnSpeed = 0.05
      const playerRadius = 0.5
      const playerHeight = 1.6
      const friction = 0.8

      let velocityY = 0
      let grounded = false
      let sprinting = false
      let wasSprintPressed = false
      let targetFov = 60
      let fovSpeed = 5
      let lastMovementTime = Date.now()
      let moveTimeout = 500

      let moveVelocity = new THREE.Vector3()
      let walls = []

      function makeWall(x, z) {
        let wall = new THREE.Mesh(
          new THREE.BoxGeometry(2, 2, 2),
          new THREE.MeshStandardMaterial({ color: 0x2222ff }),
        )
        wall.position.set(x, 1, z)
        wall.castShadow = true
        wall.receiveShadow = true
        scene.add(wall)
        walls.push(wall)
      }

      function makeWallY(x, y, z) {
        let wall = new THREE.Mesh(
          new THREE.BoxGeometry(2, 2, 2),
          new THREE.MeshStandardMaterial({ color: 0x2222ff }),
        )
        wall.position.set(x, y + 1, z)
        wall.castShadow = true
        wall.receiveShadow = true
        scene.add(wall)
        walls.push(wall)
      }

      // Sample Maze
      ;[
        [0, 0],
        [2, 0],
        [-2, 0],
        [0, -2],
        [2, -2],
        [4, -2],
        [4, 0],
        [4, 2],
        [2, 2],
        [0, 2],
        [-2, 2],
      ].forEach(([x, z]) => makeWall(x, z))
      makeWallY(-2, 2, 2)

      let floor = new THREE.Mesh(
        new THREE.PlaneGeometry(50, 50),
        new THREE.MeshStandardMaterial({ color: 0x555555 }),
      )
      floor.rotation.x = -Math.PI / 2
      floor.receiveShadow = true
      scene.add(floor)

      scene.add(new THREE.AmbientLight(0xffffff, 0.3))

      let light = new THREE.DirectionalLight(0xffffff, 1)
      light.position.set(5, 10, 7.5)
      light.castShadow = true
      scene.add(light)

      function getGamepad() {
        return navigator.getGamepads()[0]
      }

      function updateGamepad() {
        let gp = getGamepad()
        if (!gp) return

        let sprintPressed = gp.buttons[10]?.pressed
        if (sprintPressed && !wasSprintPressed) {
          sprinting = !sprinting
        }
        wasSprintPressed = sprintPressed

        targetFov = sprinting ? 75 : 60
        camera.fov += (targetFov - camera.fov) * fovSpeed * 0.1
        camera.updateProjectionMatrix()

        yawObject.rotation.y -= gp.axes[2] * turnSpeed
        camera.rotation.x -= gp.axes[3] * turnSpeed
        camera.rotation.x = Math.max(
          -Math.PI / 2,
          Math.min(Math.PI / 2, camera.rotation.x),
        )

        let forward = gp.axes[1]
        let strafe = gp.axes[0]
        let speed = sprinting ? sprintSpeed : baseSpeed

        let forwardVec = new THREE.Vector3(
          Math.sin(yawObject.rotation.y),
          0,
          Math.cos(yawObject.rotation.y),
        )
        let rightVec = new THREE.Vector3()
          .crossVectors(new THREE.Vector3(0, 1, 0), forwardVec)
          .normalize()

        moveVelocity.addScaledVector(forwardVec, forward * speed)
        moveVelocity.addScaledVector(rightVec, strafe * speed)

        if (Math.abs(forward) > 0.1 || Math.abs(strafe) > 0.1) {
          lastMovementTime = Date.now()
        }

        if (gp.buttons[0].pressed && grounded) {
          velocityY = jumpForce
          grounded = false
        }
      }

      function tryMove(dir) {
        const testMove = (axis) => {
          let newPos = yawObject.position.clone()
          newPos[axis] += dir[axis]

          let box = new THREE.Box3().setFromCenterAndSize(
            newPos.clone().add(new THREE.Vector3(0, playerHeight / 2, 0)),
            new THREE.Vector3(1, playerHeight, 1),
          )

          for (let wall of walls) {
            let wallBox = new THREE.Box3().setFromObject(wall)
            if (
              box.intersectsBox(wallBox) &&
              yawObject.position.y - playerHeight / 2 < wallBox.max.y
            )
              return false
          }

          yawObject.position[axis] += dir[axis]
          return true
        }

        testMove("x")
        testMove("z")
      }

      function handleVerticalCollision() {
        grounded = false
        let playerBottom = yawObject.position.y - playerHeight / 2

        for (let wall of walls) {
          let box = new THREE.Box3().setFromObject(wall)
          if (
            yawObject.position.x > box.min.x - 0.5 &&
            yawObject.position.x < box.max.x + 0.5 &&
            yawObject.position.z > box.min.z - 0.5 &&
            yawObject.position.z < box.max.z + 0.5
          ) {
            if (
              velocityY <= 0 &&
              playerBottom >= box.max.y - 0.05 &&
              playerBottom + velocityY <= box.max.y
            ) {
              yawObject.position.y = box.max.y + playerHeight / 2
              velocityY = 0
              grounded = true
              return
            }
          }
        }

        if (yawObject.position.y < playerHeight / 2) {
          yawObject.position.y = playerHeight / 2
          velocityY = 0
          grounded = true
        }
      }

      function animate() {
        requestAnimationFrame(animate)

        updateGamepad()

        if (Date.now() - lastMovementTime > moveTimeout) {
          sprinting = false
        }

        yawObject.position.y += velocityY
        velocityY += gravity

        moveVelocity.multiplyScalar(friction)
        tryMove(moveVelocity)

        handleVerticalCollision()

        renderer.render(scene, camera)
      }

      animate()
    </script>
  </body>
</html>
